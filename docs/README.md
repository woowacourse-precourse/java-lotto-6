### 기능 목록

1️⃣ 로또 게임 시작 및 기본 설정

-[x] 구입금액을 입력하라는 문구 출력
-[x] 사용자로부터 구입금액을 입력
    -[x] ⚠️ 유효하지 않은 값을 받았을 때 예외처리
        -[x] 숫자가 아닌 경우
        -[x] 1000원으로 나누어 떨어지지 않는 경우
        -[x] 최대 구입 금액(`10만원`)을 초과하는 경우
        -[x] 구입 금액이 0원 이하인 경우
    -[x] 유효한 값이 들어오지 않았다면 에러 메세지 출력 후, 유효한 값을 받을 때까지 입력 다시 받기

<br>

2️⃣ 게임 진행

-[x] 구입한 로또의 번호들을 생성
    -[x] Random 라이브러리를 이용하여 1에서 45 사이의 값을 총 6개 선택
    -[x] 단, 중복된 값이 없도록 한다
    -[x] 오름차순으로 저장한다 -> 한 번 정렬하기
-[x] 구입한 로또의 번호들을 생성 및 출력한다
    -[x] 이 때, 번호들은 오름차순으로 출력한다.
    -[x] 숫자 간의 구분은 쉼표(`,`)로 하며, 6개의 로또 숫자는 대괄호(`[ ]`)로 감싼다
-[x] 당첨 번호를 입력하라는 문구 출력
-[x] 사용자로부터 당첨 번호를 입력
    -[x] 당첨 번호는 쉼표(,)를 통해 구분
    -[x] 숫자 앞뒤로 공백이 있다면 제거
    -[x] ⚠️ 유효하지 않은 값을 받았을 때 예외처리
        -[x] 숫자가 아닌 값이 들어왔을 때
        -[x] 당첨 번호의 개수가 `6`개가 아닐 때
        -[x] 번호의 범위가 `1~45`의 값이 아닐 때
    -[x] 유효한 값이 들어오지 않았다면 에러 메세지 출력 후, 유효한 값을 받을 때까지 입력 다시 받기
-[x] 사용자로부터 보너스 번호를 입력
    -[x] ⚠️ 유효하지 않은 값을 받았을 때 예외처리
        -[x] 단, 보너스 번호는 당첨 번호들과 중복되지 않아야 한다.
        -[x] 숫자가 아닌 값이 들어왔을 때
        -[x] 숫자의 범위가 1~45가 아닐 때
    -[x] 유효한 값이 들어오지 않았다면 에러 메세지 출력 후, 유효한 값을 받을 때까지 입력 다시 받기

<br>

3️⃣ 게임 종료 및 결과 출력

-[x] 당첨 통계 헤더 출력
-[x] 다양한 당첨 유형 중, 몇 개가 일치하는지 계산
    -[x] 보너스 번호를 제외, 당첨 번호만을 이용하여 몇 개가 일치하는지 확인 및 저장
    -[x] `5개 일치 + 보너스 번호` 유형의 당첨은 몇 개 인지 확인
    -[x] 유형, 포멧에 맞춰서 당첨 개수를 출력
- [x] 총 수익률 계산
    -[x] 구입 금액과 수익금을 통해 총 수익률을 퍼센트 단위로 계산
    -[x] 총 수익률을 출력

---

### 2주차 피드백

-[ ] 의존성 주입을 담당하는 Factory 클래스를 만들고 적용하자
-[x] view에는 로직을 담지 말자. view는 자기 자신을 제외한 어떤 계층도 알아서는 안된다.
-[x] primitive type은 클래스로 한 번 감싸고, 검증과 같은 책임을 부여하자
-[x] 정적 팩토리 메서드의 도입을 고려해보자
-[x] 메서드의 이름을 축약하는 것은 지양하자. ex) init -> initGame
-[x] 외부 라이브러리가 포함된 부분은 변경 가능성을 고려하여 래핑/인터페이스를 활용하자
-[ ] 입출력은 비용이 크다. 한 줄씩 출력하는 것 보다, 한 번에 출력하는 방법을 이용하자
-[ ] 공통 피드백을 준수하자

---

### 프로그래밍 요구 사항

-[x] indent depth는 최대 2까지 허용
-[x] 메서드의 길이가 15 라인을 넘기지 않도록 한다
-[x] else, switch/case 문을 사용하지 않는다
-[x] Enum을 사용한다
-[x] pickUniqueNumbersInRange(), readLine()을 활용한다
-[x] Lotto 클래스를 활용
    -[x] numbers의 접근 제어자를 변경할 수 없다
    -[x] 필드를 추가하지 않는다
-[ ] 도메인 로직에 단위 테스트를 구현한다 : `test/java/lotto/LottoTest`를 참고하여 테스트를 구현한다

---

### 개발 중 정리하는 리팩토링 목록

-[x] WinningLotto
    -[x] Map을 순회하는 로직을 좀 더 가독성 있게 바꾸기
    -[x] WinningResult의 updateResult()에서 WinningResult를 너무 많이 아는 것 같으므로 변경하기
-[x] 상수로 관리할 수 있는 값들을 모두 찾아서 enum으로 빼내기
-[ ] 스파게티성 코드를 정리하자!
    -[ ] LottoService에 너무 많은 domain이 연관되어 있어 결합도가 너무 높음! 해결하기 -> 연관성 있는 것은 클래스로 따로 빼는 방법도..
    -[ ] WinningLotto에는 사용자가 입력한 당첨/보너스 번호를 담는 DTO인데, Domain과 DTO의 구분이 부족하여 코드가 복잡하다. 이를 개선해보자.
- [x] 의존성 주입을 담당하는 클래스를 따로 빼서 객체들을 관리하기
-[ ] validate에 관한 로직을 모아둘 수 있는 클래스가 따로 있으면 좋겠다.
    -[ ] 공통적인 검증 로직(null 여부, 숫자 여부)는 View에 포함시키고
    -[ ] 특정 도메인에 한정된 검증 로직은 Model에 포함시키자
-[ ] parsing처럼 여러 군데에서 사용되는 util 메서드들에 대해 클래스를 따로 빼고, static 메서드로 선언하기
-[ ] 클래스/메서드/변수명이 의도를 알아보기 쉽게 작성되었는지 확인 및 수정
-[ ] 출력에 대한 비용을 고려하여, 출력 시 메세지를 모아서 한 번에 출력하도록 변경
-[x] OutputView에서 println이 바뀌어도 타격이 적도록 인터페이스를 이용하여 변경해보기
-[ ] toString으로 사용한 부분에 대해 리팩토링 필요 : View는 Model의 데이터는 참조 가능
-[ ] 중복되는 try-catch문에 대해 클래스로 추출하기

---

### 예외가 발생했을 때 처리 방법에 대한 고찰

> 고민 내용  
> MVC 패턴에 따르면, view는 사용자 인터페이스(UI)의 역할을 하며, Model에만 의존(참조 가능)해야 하고 UI 요소 외 추가적인 연산이 이루어지지 않아야 한다.
>
> 따라서 리팩토링 이전의 코드에서는 validate 과정을 각 Model에서 진행했다.   
> 하지만 "유효하지 않은 값이 들어온다면 에러 메세지를 출력하고, 입력을 다시 받는다"라는 요구사항이 추가되었다.
>
> 그렇다면 검증은 InputView에서 해야 할까? Model에서 진행해야 할까?
> InputView에서 진행한다면, InputView가 Model에 대해 너무 많이 알 것 같고 UI 요소 외 다른 연산이 들어갈 것 같았다.
> Model에서 진행한다면, 생성자에서 예외가 발생할텐데 입력을 받는 로직을 어떻게 실행해야 할지 감이 오지 않았다.

`그렇다면 validate 과정을 무조건 Model에서만 이루어지는 것이 맞을까?`에 대한 고민이 생겼고, 구글링을 통해 자료를 모으기 시작했다.  
결론부터 이야기하자면,

1. 모든 입력에서 진행해야하는 검증 로직(ex: null 입력, 적절하지 않은 타입)에 대해서는 View에서 실행하고,
2. 각 Model들에 특화된 검증 로직(ex: 로또 번호는 1~45 사이)에 대해서는 Model에서 실행해야 한다.

위의 사항을 적용하면서 요구사항을 지키기 위해서는 예외가 발생했을 때,  
예외 메세지를 출력 -> 입력 로직부터 재시작 하는 로직은 Controller에 있는 것이 적합하겠다는 결론을 내렸다.

예외를 처리하는 로직이 Controller에 위치한다면,

1) View, Model 둘 중 어느 곳에서 예외가 발생해도 Controller에서 해당 함수들을 호출하므로 try-catch문으로 잡기 용이하며,
2) 중복되는 try-catch문의 경우, 클래스/메서드로 추출하여 중복 코드를 줄일 수 있을 것이다.

