## 🚀 요구 사항 정리
### ✏️ 기능 목록
#### 로또 구매
```
[] 로또 구입 금액 입력
[] 구매 금액에 해당하는 만큼 로또 발행
[] 당첨 번호 입력 (번호는 쉼표(,)를 기준으로 구분)
[] 보너스 번호 입력
```
#### 로또 구매 조건 체크
```
[] 로또 1장의 가격은 1,000원
[] 구입 금액이 1,000원으로 나누어 떨어지지 않는 경우 예외 처리
```
#### 로또 발행
```
[] 1~45까지의 랜덤한 번호 생성
[] 중복되지 않는 6개의 메인 번호 생성
[] 중복되지 않는 1개의 보너스 번호 생성
```
#### 로또 당첨
```
[] 1등: 6개 번호 일치 / 2,000,000,000원
[] 2등: 5개 번호 + 보너스 번호 일치 / 30,000,000원
[] 3등: 5개 번호 일치 / 1,500,000원
[] 4등: 4개 번호 일치 / 50,000원
[] 5등: 3개 번호 일치 / 5,000원
```
#### 당첨 통계
```
[] 1~5등까지의 당첨 개수(0 포함) 출력 (미당첨은 출력 안함)
[] 발행한 로또 수량 및 번호를 출력
[] 로또 번호는 오름차순으로 정렬
[] 총 수익률 계산 - 소수점 둘째 자리에서 반올림한다.
   (ex. 100.0%, 51.5%, 1,000,000.0%)
```
### 🖨️ 실행 예시
```
구입금액을 입력해 주세요.
8000

8개를 구매했습니다.
[8, 21, 23, 41, 42, 43] 
[3, 5, 11, 16, 32, 38] 
[7, 11, 16, 35, 36, 44] 
[1, 8, 11, 31, 41, 42] 
[13, 14, 16, 38, 42, 45] 
[7, 11, 30, 40, 42, 43] 
[2, 13, 22, 32, 38, 45] 
[1, 3, 5, 14, 22, 45]

당첨 번호를 입력해 주세요.
1,2,3,4,5,6

보너스 번호를 입력해 주세요.
7

당첨 통계
---
3개 일치 (5,000원) - 1개
4개 일치 (50,000원) - 0개
5개 일치 (1,500,000원) - 0개
5개 일치, 보너스 볼 일치 (30,000,000원) - 0개
6개 일치 (2,000,000,000원) - 0개
총 수익률은 62.5%입니다.
```
### 📩 추가된 요구 사항

- 함수(또는 메서드)의 길이가 15라인을 넘어가지 않도록 구현한다.
    - 함수(또는 메서드)가 한 가지 일만 잘 하도록 구현한다.
- else 예약어를 쓰지 않는다.
    - 힌트: if 조건절에서 값을 return하는 방식으로 구현하면 else를 사용하지 않아도 된다.
    - else를 쓰지 말라고 하니 switch/case로 구현하는 경우가 있는데 switch/case도 허용하지 않는다.
- Java Enum을 적용한다.
- 도메인 로직에 단위 테스트를 구현해야 한다. 단, UI(System.out, System.in, Scanner) 로직은 제외한다.
    - 핵심 로직을 구현하는 코드와 UI를 담당하는 로직을 분리해 구현한다.
    - 단위 테스트 작성이 익숙하지 않다면 `test/java/lotto/LottoTest`를 참고하여 학습한 후 테스트를 구현한다.
```
Lotto 클래스

- 제공된 `Lotto` 클래스를 활용해 구현해야 한다.
- `numbers`의 접근 제어자인 private을 변경할 수 없다.
- `Lotto`에 필드(인스턴스 변수)를 추가할 수 없다.
- `Lotto`의 패키지 변경은 가능하다.
```
```
예외 처리

사용자가 잘못된 값을 입력할 경우 IllegalArgumentException를 발생시키고,
"[ERROR]"로 시작하는 에러 메시지를 출력 후 그 부분부터 입력을 다시 받는다.
Exception이 아닌 IllegalArgumentException,
IllegalStateException 등과 같은 명확한 유형을 처리한다.
```
## 🚀 NOTE
### ❓ Java Enum
#### 상수만을 다루는 enum 타입 클래스
- enum의 핵심은 상수를 단순히 정수로 치부하지 말고 객체 지향적으로 객체화해서 관리하자는 취지다.
- Java의 enum은 인터페이스와 같이 독립된 특수한 클래스로 구분한다.
- 일종의 객체이기 때문에 힙(heap) 메모리에 저장된다.
- 각 enum 상수들은 별개의 메모리 주소 값을 가짐으로써 완벽히 독립된 상수를 구성할 수 있다.
- 또한 IDE에서 클래스 파일을 생성할 때 독립된 열거형 파일도 생성할 수 있다.
#### enum 선언
```java
enum Week { //enum명은 클래스와 같이 첫문자 대문자, 나머지 소문자로 작성
  MONDAY, TUESDAY, WEDNESDAY_NIGHT; //열거 상수는 모두 대문자, 여러 단어의 경우 밑줄(_)
}
```
#### enum 참조 방식
```java
//열거타입 변수 = 열거타입.열거상수;
Week monday = Week.MONDAY;
Week sunday = Week.SUNDAY;
```
primitive 타입이 아닌 reference 타입으로 분류되며, enum 상수 값은 힙 영역에 저장된다.<br>
스택 영역에 있는 변수들이 힙 영역에 있는 데이터의 주소값을 저장함으로써 참조 형태를 띄게 된다.
```java
Week today = null; //참조 타입이기 때문에 null도 저장 가능
today = Week.MONDAY;

//주소값 비교
System.out.println(today == Week.SUNDAY); //true
```
enum 상수들을 배열로 만들어 저장할 때도 각 배열 원소들마다 참조 주소값들이 저장되어<br>
힙 영역의 상수 데이터들을 가리키게 된다.
```java
//enum Week 의 모든 상수값들을 배열로 변환 
Week[] days = Week.values();
```

참고 링크 : https://blog.naver.com/nevertheless113/223255748354
### ❓ 단위 테스트
- 단위 테스트는 단순히 버그를 찾기 위한 효과적인 방법이 아니다.
- 정의에 따르면 단위 테스트는 시스템의 각각의 단위들을 개별적으로 조사하는 것이다.
- 단위 테스트 작성 시 가장 중요하게 인식할 점은 테스트 단위가 복수의 테스트 시나리오들을 가질 수 있다는 것이다.
- 모든 테스트 시나리오들은 독립적인 테스트 코드로 작성되어야 한다.<br>
  (하나의 테스트 코드를 수정할 경우 의존성을 가지고 있는 다른 코드를 수정해야 하는 경우를 방지)
- 시스템 설정은 단위 테스트의 범위가 아니다.
- 단위 테스트 케이스의 이름은 명확하고 일관되게 테스트의 의미를 반영해야 한다.
  ```
  테스트 케이스 이름의 좋은 예
  1) TestCreateEmployee_NullId_ShouldThrowException
  2) TestCreateEmployee_NegativeId_ShouldThrowException
  3) TestCreateEmployee_DuplicateId_ShouldThrowException
  4) TestCreateEmployee_ValidId_ShouldPass
  ```
- 외부 시스템이나 서비스에 대한 의존성이 가장 낮은 메소드들에 대해 테스트를 먼저 작성하고 확장해가야 한다.
- 테스트 코드 내에서 아무것도 출력하지 말아야 한다.

예를 들어, 매개변수를 가지고 처리한 후 값을 돌려주는 함수의 테스트 케이스를 작성한다고 하면,<br>
다음과 같은 테스트 시나리오가 가능하다.

1. 첫 번째 파라미터가 null 값일 경우 예외 객체를 반환해야 한다.
2. 두 번째 파라미터가 null 값일 경우 예외 객체를 반환해야 한다.
3. 두 개의 파라미터 모두가 null 값일 경우 예외 객체를 반환해야 한다.
4. 파라미터가 정상 범위 안일 경우 작업 실행 후 결과 값을 반환해야 한다.

이러한 세분화된 테스트 케이스들은 코드를 수정하거나 리팩토링시 효과적이다.<br>
단위 테스트만 수행하면 코드의 수정이 코드의 의도된 기능을 망가뜨렸는지 확인할 수 있기 때문이다.<br>
또한 기능을 수정한다면 최소한의 테스트 코드만 수정하면 되기 때문이다.

참고 링크 : https://blog.naver.com/sipzirala/220942214766