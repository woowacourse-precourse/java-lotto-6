# 로또 게임
- 로또 게임 기능을 구현해야 한다. 로또 게임은 아래와 같은 규칙으로 진행된다.
  ```
  - 로또 번호의 숫자 범위는 1~45까지이다.
  - 1개의 로또를 발행할 때 중복되지 않는 6개의 숫자를 뽑는다.
  - 당첨 번호 추첨 시 중복되지 않는 숫자 6개와 보너스 번호 1개를 뽑는다.
  - 당첨은 1등부터 5등까지 있다. 당첨 기준과 금액은 아래와 같다.
    - 1등: 6개 번호 일치 / 2,000,000,000원
    - 2등: 5개 번호 + 보너스 번호 일치 / 30,000,000원
    - 3등: 5개 번호 일치 / 1,500,000원
    - 4등: 4개 번호 일치 / 50,000원
    - 5등: 3개 번호 일치 / 5,000원
    ```

## 과제를 하면서 고민한 것들 
- [상수 정리](https://uhanuu.tistory.com/entry/%EB%A7%A4%EC%A7%81%EB%84%98%EB%B2%84-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EC%96%B4%EB%94%94%EA%B9%8C%EC%A7%80-%EC%83%81%EC%88%98-%EC%B2%98%EB%A6%AC%ED%95%B4%EC%95%BC-%EB%8F%BC)
  - : 매직넘버, 리터럴 어디까지 상수 처리해야 되는지 고민했습니다.
- Input, Output View의 Interface 사용을 고민했습니다.
  ```
  코드 리뷰를 하면서 File입출력을 고민하시고 interface를 도입하신분들이 많았습니다.
  
  이번 Input 로직은 예외처리를 깔끌하게 하고 싶어서 Proxy 패턴을 적용하려고 Interface를 사용하게 되었고
  사용한 만큼 File 입출력도 대비하고자 해서 Console전용 인터페이스를 만들게 되었습니다.
  
  Output에 대해서는 로또 구매 출력 로직과, 로또 당첨 결과를 출력하는 로직을 분리했는데
  이걸 하나의 인터페이스로 묶어서 처리하게 되면 확장성과 유지보수성을 가져갈 수 있다고 하지만 
  코드가 더 복잡해질 수 있으므로 불필요한 복잡성이 증가가 된다고 생각했습니다.
  
  구조를 합치고 Output 인터페이스를 사용하는게 어떤 이점이 더 있을지 궁금합니다!
  ```
- 객체에 대한 검증을 할 때 입력값으로 검증된 데이터로만 생성을 하는데 객체에서 검증을 해야될까 고민했습니다.
  - 로또 객체에 관련된건 객체 안에서 검증하기로 했고 보너스 번호, 사용자 입력금액에 대해서만 검증했습니다.
    ```java
    public class Lotto {
    private final List<Integer> numbers;

    public Lotto(List<Integer> numbers) {
        validate(numbers);
        this.numbers = numbers;
    }

    private void validate(List<Integer> numbers) {
        if (numbers.size() != 6) {
            throw new IllegalArgumentException();
        }
    }

    // TODO: 추가 기능 구현
    }
    ```
    - **Integer**인 로또 번호를 원시 타입으로 포장하는 것이 활용한다는 키워드에서 부합한지 모르겠어서 적용하지 않았습니다.
      - 로또 번호또한 하나의 객체라고 생각해서 원시타입으로 포장하고 로또에서 번호는 로또에서 검증하지 않는 방식도 괜찮을거 같았습니다.
    - view, service로직에서 한 뎁스를 더 타고 들어가야되서 좀 더 무거운 느낌은 들겠지만 객체로 잘 나눈거 같아서 괜찮을거 같은데 다른 분들에 의견이 궁금합니다.

## 📂 디렉토리 구조
```
├── main
│   └── java
│       └── lotto
│           ├── Application.java
│           ├── constants
│           ├── controller
│           ├── domain
│           │   └── lotto
│           ├── dto
│           ├── message
│           ├── util
│           └── view
│               ├── input
│               │    ├── message
│               │    └── validator
│               └── output
└── test             └── message
    └── java
        └── lotto
            ├── ApplicationTest.java
            ├── domain
            │   └── lotto
            ├── util
            ├── validator
            └── view
                ├── input
                ├── output
                └── DisplayTestSupport.java
```
---
## 구입 금액을 담당하는 기능 [Cash] - 로또는 현금이지~
- [X] 금액이 양수가 아니면 예외가 발생한다.
- [X] 해당 물건을 구입가능한지 체크할 수 있다.
- [X] 현재 금액으로 물건을 몇개 살 수 있는지 반환할 수 있다.

## 로또 여러개를 담당하는 기능 [Lottos]
- 로또들의 당첨 개수를 통해서 해당하는 로또 순위가 몇개인지 반환하는 Map을 가지고 있다.
  - Map의 구현체는 EnumMap이기 때문에 Key로 로또 순위의 값만 올 수 있다.

## 로또 순위의 정보를 담고 있는 기능 [LottoRank]
- [X] 당첨된 로또 번호 개수를 통해서 로또 순위를 가져올 수 있다.
- [X] 당첨된 금액을 계산할 수 있다.
- [X] 당첨된 순위의 메시지가 담겨있다.


## 로또를 담당하는 기능 [Lotto]
- [X] 로또 번호 6개를 중복되지 않고 오름차순 데이터만 저장하는 자료구조
  - 1~45 사이의 숫자가 아니면 예외가 발생한다.
  - 6자리가 아니면 예외가 발생한다.
  - 중복된 숫자가 있으면 예외가 발생한다.
  - 오름차순으로 정렬되어 있지 않으면 예외가 발생한다.

## 사용자에게 입력 기능 [view-input]
- [X] 로또 구입 금액을 입력
  - 로또 구입 금액을 입력 받는다. 구입 금액은 1,000원 단위로 입력 받으며 
    - 구입 금액이 1000으로 나누어 떨어지지 않으면 예외가 발생한다.
- [X] 당첨 번호를 입력 받는다. 번호는 쉼표(,)를 기준으로 구분한다.
    - 오름차순으로 정렬이 되어 입력하지 않으면 예외가 발생한다.
    - 숫자의 범위가 1-45가 아니면 예외가 발생한다.
    - 로또 숫자를 6자리 입력하지 않으면 예외가 발생한다.
- [X] 보너스 번호를 입력 받는다.
    - 숫자의 범위가 1-45가 아니면 예외가 발생한다.
    - 당첨 번호에 포함된 숫자를 입력하면 예외가 발생한다.
- [X] "[ERROR]"로 시작하는 에러 메시지를 출력 후 그 부분부터 입력을 다시 받는다.
    - Proxy 객체에서 예외발생 시 1회 재시도 한다. (ProxyInputView)

## 구입 금액에 해당하는 만큼 로또를 발행하는 유틸 기능 [util-LottoShop]
- [X] 구입 금액에 해당하는 만큼 로또를 발행해야 한다.
  - 로또 1장의 가격은 1,000원이다.
    - 구입 금액이 로또 가격으로 나누어 떨어지지 않으면 예외가 발생한다.

## 로또를 생성하는 유틸 기능 [util-LottoFactory]
- [X] 1부터 45사이의 6자리 수가 담긴 List<Integer>을 반환한다.
  - 우테코의 Randoms.pickUniqueNumbersInRange() 메서드를 활용한다.
  - 우테코 라이브러리를 통해서 숫자를 받고 오름차순으로 정렬해서 생성한다.
- [X] List에 담긴 숫자들을 파라미터로 전달받아서 로또를 생성할 수 있다.

## 사용자가 구매한 로또 번호와 금액을 가지고 있는 DTO [LottoGameInfo]
- [X] 사용자의 구입 금액과 구매한 로또들은 가지고 있다.

## 당첨 번호와 보너스 번호를 가지고 있는 DTO [LottoResult]
- [X] 사용자의 입력으로 들어온 당첨 번호와 보너스 번호를 가지고 있다. 

## 출력을 담당하는 기능 [view-output]
- 당첨 내역 및 수익률을 출력할 수 있다.
  - 총 수익률은 62.5%입니다.
  - 구입한 금액을 통해서 수익률을 계산할 수 있다.
  - 수익률은 소수점 **둘째 자리**에서 반올림한다. 
  - (ex. 100.0%, 51.5%, 1,000,000.0%)
- 발행한 로또 수량 및 번호를 출력한다. 로또 번호는 **오름차순**으로 정렬하여 보여준다.
    ```
    8개를 구매했습니다.
    [8, 21, 23, 41, 42, 43]
    [3, 5, 11, 16, 32, 38]
    [7, 11, 16, 35, 36, 44]
    [1, 8, 11, 31, 41, 42]
    [13, 14, 16, 38, 42, 45]
    [7, 11, 30, 40, 42, 43]
    [2, 13, 22, 32, 38, 45]
    [1, 3, 5, 14, 22, 45]
    ```
    - 당첨 내역을 출력한다.
      ```
      3개 일치 (5,000원) - 1개
      4개 일치 (50,000원) - 0개
      5개 일치 (1,500,000원) - 0개
      5개 일치, 보너스 볼 일치 (30,000,000원) - 0개
      6개 일치 (2,000,000,000원) - 0개
      ```

## 검증을 담당하는 기능 [input-validator]
- [X] 사용자가 잘못된 값을 입력할 경우 IllegalArgumentException를 발생시킨다.
  - 사용자의 잘못된 값은 inputView에서만 체크하기 때문에 패키지를 view.input 패키지 안에 생성한다.
  - input에 발생한 예외는 여기서 전부 처리하며 "[ERROR]"로 시작하는 에러 메시지를 출력한다.
- [X] Exception이 아닌 IllegalArgumentException, IllegalStateException 등과 같은 명확한 유형을 처리한다.

## 게임을 담당하는 기능 [controller]
- [X] 게임의 시작과 종료를 담당한다.

## 프로그램 요구사항
- indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 
  - 2까지만 허용한다.
- 3항 연산자를 쓰지 않는다.
- 변수 이름에 자료형은 사용하지 않는다
  - 변수 이름에 자료형, 자료 구조 등을 사용하지 마라.
  ```
  String carNameList = Console.readLine();
  String[] arrayString = carNameList.split(",");
  ```
- 안내 문구 출력, 사용자 입력, 유효값 검증 등 여러 일을 하고 있다면 이를 적절하게 분리한다.
- 단지 기능을 점검하기 위한 목적으로 테스트를 작성하는 것은 아니다. 
  - 테스트를 작성하는 과정을 통해서 나의 코드에 대해 빠르게 피드백을 받을 수 있을 뿐만 아니라

### 추가된 요구사항
- 함수(또는 메서드)의 길이가 15라인을 넘어가지 않도록 구현한다.
- **함수(또는 메서드)가 한 가지 일만 잘 하도록 구현한다.**
  - 무조건 한 가지만
- else 예약어를 쓰지 않는다.
  - 힌트: if 조건절에서 값을 return하는 방식으로 구현하면 else를 사용하지 않아도 된다.
  - else를 쓰지 말라고 하니 switch/case로 구현하는 경우가 있는데 switch/case도 허용하지 않는다.
- Java Enum을 적용한다.

- test
  - 도메인 로직에 단위 테스트를 구현해야 한다. 
    - 단, UI(System.out, System.in, Scanner) 로직은 제외한다. // view test 제외
  - 핵심 로직을 구현하는 코드와 UI를 담당하는 로직을 분리해 구현한다.
  - 단위 테스트 작성이 익숙하지 않다면 test/java/lotto/LottoTest를 참고하여 학습한 후 테스트를 구현한다.