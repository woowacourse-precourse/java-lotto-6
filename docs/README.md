# 1주차 공통 피드백

---
##### 1. 요구사항 정확히 준수
##### 2. **의미 있는 커밋 메시지** 작성
##### 3. .girignore 활용하여 .class파일 및 .idea폴더는 깃으로 관리 하지 않는다.
##### 4. pr을 보내기 전 브랜치 확인
##### 5. PR을 작성 후 추가 커밋시 닫지 않고 커밋
##### 6. **의미있는 단어를 활용**하려 변수, 메서드 등... 작성한다.
##### 7. **축약하지 않는다.**
##### 8. 공백도 컨벤션이다. **공백 라인도 의미있게 사용**하자.
##### 9. space와 tap을 혼돈하지 않는다.
##### 10. **의미 없는 주석은 달지 않는다.**(메서드, 변수 이름을 통해 의도를 드러내고, 드러내기 힘든 경우 주석을 작성하자)
##### 11. **자동 정렬을 적극 활용**하자
##### 12. **Java에서 제공하는 API를 적극 활용**하자
##### 13. **배열대신 Java Collection을 사용**한다.

# 2주차 공통 피드백

---
##### 1. README 작성
- README.md를 **상세히 작성**한다.
- 해당 프로젝트가 어떠한 프로젝트이며, 어떤 기능을 담고 있는지 기술하기 위해서 **마크다운 문법을 검색해서 학습해 보고 적용**해 본다.
- 기능 목록을 재검토한다
- 기능 목록을 클래스 설계와 구현, 함수(메서드) 설계와 구현과 같이 **너무 상세하게 작성하지 않는다**.
- 정상적인 경우도 중요하지만, **예외적인 상황도 기능 목록에 정리**한다. 기능을 구현하면서 계속해서 추가해 나간다.
- 기능을 구현하면서 **변경되는 사항이 발생하면 기능 목록을 업데이트**한다.
##### 2. 값을 **하드 코딩하지 않는다.**
##### 3. 구현 순서도 코딩 컨벤션이다(클래스는 **상수, 멤버 변수, 생성자, 메서드 순으로 작성**한다.)
##### 4. **변수 이름에 자료형은 사용하지 않는다.**
##### 5. **한 함수가 한 가지 기능만 담당**하게 한다.
##### 6. 함수가 **한 가지 기능을 하는지 확인하는 기준을 세운다.**
##### 7. 테스트를 작성하는 이유에 대해 본인의 경험을 토대로 정리해본다. - [JUnit 학습하기.pdf](https://techcourse-storage.s3.ap-northeast-2.amazonaws.com/9b82d8a360c548fcadd14c551dbcbe06)
##### 8. 처음부터 **큰 단위의 테스트를 만들지 않는다.**
```
- 큰 단위의 테스트
  - 자동차경주를 시작해서 사용자가 이름, 진행 횟수를 입력하면, 게임을 진행한 후 그 결과를 알려준다.
- 작은 단위의 테스트
  - 무작위 값이 4 이상이면 자동차가 전진한다.
  - 무작위 값이 3 이하이면 자동차가 전진하지 않는다.
```

# 프리코스 목표

---
##### 1. 함수를 작은 단위로 분리
##### 2. 각 함수별로 테스트를 작성하는 것에 익숙해지는 것을 목표
##### 3. 클래스(객체)를 분리하는 연습
##### 4. 도메인 로직에 대한 단위 테스트를 작성하는 연습

# 시작 전 확인 사항(프로그래밍 요구사항)

---
- JDK 17 환경에서 개발한다.
- build.gradle을 수정할 수 없고 추가적인 라이브러리를 사용하지 않는다.
- 프로그램 종료는 System.exit()을 호출하지 않는다.
- 모든 테스트는 통과되어야 한다.
- 따로 명시가 없을 시 파일, 패키지 이름을 수정하거나 이동하지 않는다.(명시 없음)
- 들여쓰기 depth는 3이 넘지 않도록 구현한다.
- 3항 연산자는 사용하지 않는다.
- 함수는 한 가지 일만 하도록 최대한 작게 만들어라.
- JUnit, AssertJ를 이용하여 정리한 기능 목록이 정상 동작함을 테스트 코드로 확인한다.(test/java/study를 참고해 학습 후 테스트 구현)
- 함수(또는 메서드)의 길이가 15라인을 넘어가지 않도록 구현한다.
- else 예약어를 쓰지 않는다.
- Java Enum을 적용한다.
- 도메인 로직에 단위 테스트를 구현해야 한다. 단, UI(System.out, System.in, Scanner) 로직은 제외한다.
- 핵심 로직을 구현하는 코드와 UI를 담당하는 로직을 분리해 구현한다.
    - 단위 테스트 작성이 익숙하지 않다면 test/java/lotto/LottoTest를 참고하여 학습한 후 테스트를 구현한다.
- camp.nextstep.edu.missionutils에서 제공하는 Randoms 및 Console API를 사용하여 구현
   ```java
   // 사용 예시
   List<Integer> numbers = Randoms.pickUniqueNumbersInRange(1, 45, 6);
   ```
- Lotto 클래스 활용
    - 제공된 `Lotto` 클래스를 활용해 구현해야 한다.
    - `numbers`의 접근 제어자인 private을 변경할 수 없다.
    - `Lotto`에 필드(인스턴스 변수)를 추가할 수 없다.
    - `Lotto`의 패키지 변경은 가능하다.

# 기능 목록 정리

---
- 입력받은 금액을 횟수로 변환.
- 매개 변수로 발급 횟수를 받아서 발급 횟수만큼 중복되지 않는 숫자를 뽑는다.
- 문구를 받아서 출력하고 입력받음.
- 당첨 번호, 발급 번호를 넘겨 받고 일치 하는 횟수 출력
- 수익률 계산.

# 예외 상황 정리

---
##### 에러 시 `[ERROR] 로또 번호는 1부터 45 사이의 숫자여야 합니다.` 와 같은 문구 출력
##### `Exception`이 아닌 `IllegalArgumentException`, `IllegalStateException` 등과 같은 명확한 유형을 처리한다.
- 로또 구입 금액을 입력 받을 때 예외
  - 구입 금액이 숫자가 아닌 값이 들어온 경우
  - 천원 단위로 끊어지지 않는 경우
  - 1000보다 작은 값이 입력된 경우
- 당첨 번호는 입력 받을 때 예외
  - 숫자와 콤마가 아닌 값이 들어온 경우
  - 당첨 번호가 0 미만 45를 초과인 경우
- 보너스 번호가 입력 받을 때 예외
  - 보너스 번호가 아닌 값이 들어온 경우
  - 보너스 번호가 0 미만 45를 초과인 경우

# 개발 방향성

---
- 로또 게임을 진행하는 클래스 생성
- 각종 유틸을 수행하는 유틸 클래스 생성
- 에러 문구 이넘 클래스 생성.